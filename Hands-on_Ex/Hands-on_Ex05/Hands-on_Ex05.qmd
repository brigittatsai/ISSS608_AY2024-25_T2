---
title: "Hands-on Exercise 5"
author: "Brigitta Karen Tsai"
date: "February 8, 2025"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  message: false
  freeze: true
---

# Part 1: Creating Ternary Plot with R

# 1 Getting Started

## 1.1 Install and Load R Packages

```{r}
pacman::p_load(plotly, ggtern, tidyverse)
```

# 2 Data Preparation

## 2.1 Import Data

```{r}
pop_data <- read_csv("data/respopagsex2000to2018_tidy.csv") 
```

## 2.2 Preparing the Data

Use **mutate()** to derive new measures **young**, **economy active** and **old**

```{r}
agpop_mutated <- pop_data %>%
  mutate(`Year` = as.character(Year))%>%
  spread(AG, Population) %>%
  mutate(YOUNG = rowSums(.[4:8]))%>%
  mutate(ACTIVE = rowSums(.[9:16]))  %>%
  mutate(OLD = rowSums(.[17:21])) %>%
  mutate(TOTAL = rowSums(.[22:24])) %>%
  filter(Year == 2018)%>%
  filter(TOTAL > 0)
```

# 3 Plotting Ternary Diagram with R

## 3.1 Plotting a static ternary diagram

Use **ggtern()** function from **ggtern** package to create a simple ternary plot

```{r}
ggtern(data=agpop_mutated,aes(x=YOUNG,y=ACTIVE, z=OLD)) +
  geom_point()
```

Now let's add colors to each category

```{r}
ggtern(data=agpop_mutated, aes(x=YOUNG,y=ACTIVE, z=OLD)) +
  geom_point() +
  labs(title="Population structure, 2015") +
  theme_rgbw()
```

## 3.2 Plotting an interactive ternary diagram

The code below create an interactive ternary plot using **plot_ly()** function of **Plotly R**

```{r}
# reusable function for creating annotation object
label <- function(txt) {
  list(
    text = txt, 
    x = 0.1, y = 1,
    ax = 0, ay = 0,
    xref = "paper", yref = "paper", 
    align = "center",
    font = list(family = "serif", size = 15, color = "white"),
    bgcolor = "#b3b3b3", bordercolor = "black", borderwidth = 2
  )
}

# reusable function for axis formatting
axis <- function(txt) {
  list(
    title = txt, tickformat = ".0%", tickfont = list(size = 10)
  )
}

ternaryAxes <- list(
  aaxis = axis("Young"), 
  baxis = axis("Active"), 
  caxis = axis("Old")
)

# Initiating a plotly visualization 
plot_ly(
  agpop_mutated, 
  a = ~YOUNG, 
  b = ~ACTIVE, 
  c = ~OLD, 
  color = I("black"), 
  type = "scatterternary"
) %>%
  layout(
    annotations = label("Ternary Markers"), 
    ternary = ternaryAxes
  )
```

Now you can interactively hover and see the value of each point

# Part 2: Visual Correlation Analysis

# 1 Getting Started

## 1.1 Install and Load R Packages

```{r}
pacman::p_load(corrplot, ggstatsplot, tidyverse)
```

## 1.2 Import Data

```{r}
wine <- read_csv("data/wine_quality.csv")
```

# 2 Building Correlation Matrix: pairs() method

## 2.1 Basic Correlation Matrix

```{r}
pairs(wine[,1:11])
```

Now let us build the scatterplot matrix for column 2 to 12

```{r}
pairs(wine[,2:12])
```

## 2.2 Drawing the lower corner

Since correlation matrix is symmetric, let us only show the lower half of the matrix using the code below.

```{r}
pairs(wine[,2:12], upper.panel = NULL)
```

Now let us show the upper half of the correlation matrix

```{r}
pairs(wine[,2:12], lower.panel = NULL)
```

## 2.3 Including with Correlation Coefficients

The code will show the correlation coefficient of the variables pair instead of a scatter plot.

```{r}
panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y, use="complete.obs"))
txt <- format(c(r, 0.123456789), digits=digits)[1]
txt <- paste(prefix, txt, sep="")
if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex.cor * (1 + r) / 2)
}

pairs(wine[,2:12], 
      upper.panel = panel.cor)
```

# 3 Visualising Correlation Matrix: ggcorrmat()

There are 3 R Packages that provide the functions to plot correlation matrix:

1.  corrgram
2.  ellipse
3.  corrplot

This section will cover ggcorrmat() from **ggstatsplot** package

## 3.1 The Basic Plot

::: panel-tabset
### Basic Code

```{r}
ggstatsplot::ggcorrmat(
  data = wine, 
  cor.vars = 1:11)
```

### Statistical Report

```{r}
ggstatsplot::ggcorrmat(
  data = wine, 
  cor.vars = 1:11,
  ggcorrplot.args = list(outline.color = "black", 
                         hc.order = TRUE,
                         tl.cex = 10),
  ggplot.component = list(
    theme(text=element_text(size=3),
      axis.text.x = element_text(size = 7),
      axis.text.y = element_text(size = 7))),
  title    = "Correlogram for wine dataset",
  subtitle = "Four pairs are no significant at p < 0.05"
)

```
:::

-   **cor.vars** is used to compute the correlation matrix needed to build the corrgram

-   **ggcorrplot.args** provides additional (aesthetics) to be passed to ggcorrplot::ggcorrplot function. The list should avoid the following arguments since they are already being used internally: **corr, method, p.mat, sig.level, ggtheme, colors, lab, pch, legend.title, digits.**

# 4 Building Multiple Plots

ggstatsplot supports faceting, but the feature is not available in ggcorrmat(), but in the **grouped_ggcorrmat()** function of **ggstatsplot**

```{r}
grouped_ggcorrmat(
  data = wine,
  cor.vars = 1:11,
  grouping.var = type,
  type = "robust",
  p.adjust.method = "holm",
  plotgrid.args = list(ncol = 2),
  ggcorrplot.args = list(outline.color = "black", 
                         hc.order = TRUE,
                         tl.cex = 10),
  annotation.args = list(
    tag_levels = "a",
    title = "Correlogram for wine dataset",
    subtitle = "The measures are: alcohol, sulphates, fixed acidity, citric acid, chlorides, residual sugar, density, free sulfur dioxide and volatile acidity",
    caption = "Dataset: UCI Machine Learning Repository"
  )
)
```

# 5 Visualising Correlation Matrix using corrplot Package

## 5.1 Getting Started with corrplot

```{r}
wine.cor <- cor(wine[, 1:11])
```

Use **corrplot()** to plot the corrgram

```{r}
corrplot(wine.cor)
```

## 5.2 Working with Visual Geometrics

In **corrplot** package, there are seven visual geometrics (parameter method) can be used to encode the attribute values. They are: circle, square, ellipse, number, shade, color and pie.

```{r}
corrplot(wine.cor, 
         method = "ellipse") 
```

## 5.3 Working with Layout

**corrplot()** supports 3 layout types: **full, upper** or **lower**

::: panel-tabset
### Basic Layout

```{r}
corrplot(wine.cor, 
         method = "ellipse", 
         type="lower")
```

### Customised

```{r}
corrplot(wine.cor, method = "ellipse", type="lower", diag = FALSE, tl.col = "black")
```
:::

## 5.4 Working with Mixed Layout

```{r}
corrplot.mixed(wine.cor, 
               lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

## 5.5 Combining corrgram with the Significant Test

Using the corrplot package, we can use **cor.mtest()** to compute p-values and confidence interval of each pair of variables.

```{r}
wine.sig = cor.mtest(wine.cor, conf.level= .95)
```

```{r}
corrplot(wine.cor,
         method = "number",
         type = "lower",
         diag = FALSE,
         tl.col = "black",
         tl.srt = 45,
         p.mat = wine.sig$p, # use the p-value computation here
         sig.level = .05)
```

## 5.6 Reorder a corrgram

Matrix reordering is important for mining the hidden structure and pattern in a corrgram. There are 4 supported sorting methods:

1.  **AOE** is for the angular order
2.  **FPC** is for first principal component order
3.  **hclust** is for hierarchical clustering order, **hclust.method** for the agglomeration method to be used:
    -   **hclust.method** should be one of **ward, single, complete, average, mcquitty, median,** or **centroid**
4.  **alphabet** for alphabetical order

```{r}
corrplot.mixed(wine.cor, 
               lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               order="AOE",
               tl.col = "black")
```

## 5.7 Reordering a correlation matrix using hclust

```{r}
corrplot(wine.cor, 
         method = "ellipse", 
         tl.pos = "lt",
         tl.col = "black",
         order="hclust",
         hclust.method = "ward.D",
         addrect = 3)
```

# Part 3: Heatmap for Visualising and Analysing Multivariate Data

# 1 Getting Started

## 1.1 Install and Load Packages

```{r}
pacman::p_load(seriation, dendextend, heatmaply, tidyverse)
```

## 1.2 Import Data

```{r}
wh <- read_csv("data/WHData-2018.csv")
```

## 1.3 Data Preparation

Change the rows by country name instead of row number

```{r}
row.names(wh) <- wh$Country
```

## 1.4 Transforming the dataframe into a matrix

```{r}
wh1 <- dplyr::select(wh, c(3, 7:12))
wh_matrix <- data.matrix(wh)
```

# 2 Static Heatmap

List of R Packages to draw static heatmaps:

1.  heatmap() of R stats package
2.  heatmap.2() of gplots R package
3.  phearmap() of pheatmap R packace
4.  ComplexHeatmap package of R/Bioconductor package
5.  superheat package

## 2.1 heatmap() of R Stats

```{r}
wh_heatmap <- heatmap(wh_matrix,
                      Rowv=NA, Colv=NA)
```

heatmap() plots a cluster heatmap by default, the arguments Rowv=NA and Colv=NA are used to switch off the option of plotting the row and column dendograms.

To plot a cluster heatmap, use the default code below:

```{r}
wh_heatmap <- heatmap(wh_matrix)
```

The code chunk below is used to normalise the matrix column-wise.

```{r}
wh_heatmap <- heatmap(wh_matrix,
                      scale="column",
                      cexRow = 0.6, 
                      cexCol = 0.8,
                      margins = c(10, 4))
```

# 3 Creating Interactive Heatmap

**heatmaply** is a package to build interactive cluster heatmap that can be shared online as a stand-alone HTML file.

## 3.1 Working with heatmaply

```{r}
heatmaply(mtcars)
```

The code chunk below is to create an interactive heatmap using heatmaply package

```{r}
heatmaply(wh_matrix[, -c(1, 2, 4, 5)])
```

## 3.2 Data Transformation

When doing multivariate analysis, we need to do data transformation as different variables has different ranges. There are 3 main data transformations supported by **heatmaply()**, such as scale, normalise and percentize

### 3.2.1 Scaling Method

When all variables are from a **normal distribution**, then scaling would bring them all close to the standard normal distribution. In this case, each value would reflect the distance from the mean in units of standard deviation.

The code chunk below is used to scale variable columnwise

```{r}
heatmaply(wh_matrix[, -c(1, 2, 4, 5)],
          scale = "column")
```

### 3.2.2 Normalising Method

When variables in the data comes from different/ **non-normal distributions**, the normalize function can be used to bring data to the 0 to 1 scale by subtracting the minimum and dividing by the maximum of all observations.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]))
```

### 3.3.3 Precentising Method

This method is the percent of observations to help each value to have a clear interpretation.

```{r}
heatmaply(percentize(wh_matrix[, -c(1, 2, 4, 5)]))
```

## 3.3 Clustering Algorithm

**heatmaply** supports a variety of hierarchical clustering algorithm. The main arguments are:

1.  distfun: function used to compute the distance (dissimilarity) between both rows and columns. There are 3 options, "pearson", "spearman" and "kendall"
2.  hclustfun: used to compute the hierarchical clustering when Rowv or Colv are not dendograms
3.  dist_method default is NULL, which results in "euclidean" to be used
4.  hclust_method default is NULL, which results in "complete" method to be used

## 3.4 Manual Approach

In the code below, the heatmap is plotted using hierarchical clustering algorithm using **Euclidean distance** and **ward.D** method

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          dist_method = "euclidean",
          hclust_method = "ward.D")
```

## 3.5 Statistical Approach

To determine the best clustering method and the number of clusters, we will use **dend_expend()** and **find_k()** functions of the **dendextend** package

```{r}
wh_d <- dist(normalize(wh_matrix[, -c(1, 2, 4, 5)]), method = "euclidean")
dend_expend(wh_d)[[3]]
```

Next, determine the optimal number of clusters

```{r}
wh_clust <- hclust(wh_d, method = "average")
num_k <- find_k(wh_clust)
plot(num_k)
```

From the chart above, we can conclude that k=3 is optimal. The code below will plot the hierarchical clustering heatmap

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          dist_method = "euclidean",
          hclust_method = "average",
          k_row = 3)
```

## 3.6 Seriation

**heatmaply** uses seriation package to find the optimal ordering of rows and columns.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "OLO")
```

The default option is **OLO** (Optimal Leaf Ordering). Another option is **GW** (Gruvaeus and Wainer) which aims for the same goal but uses a potentially faster heuristic.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "GW")
```

The code chunk below will try the **mean** option, which will give the default output from th e heatmap function

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "mean")
```

**none** will give dendograms without any rotation

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "none")
```

## 3.7 Working with Colour Palettes

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "none",
          colors = Blues)
```

## 3.8 The Finishing Touch

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          Colv=NA,
          seriate = "none",
          colors = Blues,
          k_row = 5,
          margins = c(NA,200,60,NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main="World Happiness Score and Variables by Country, 2018 \nDataTransformation using Normalise Method",
          xlab = "World Happiness Indicators",
          ylab = "World Countries"
          )
```

# Part 4: Visual Multivariate Analysis

# 1 Getting Started

## 1.1 Install and Load R Packages

```{r}
pacman::p_load(GGally, parallelPlot, tidyverse)
```

## 1.2 Data Preparation

```{r}
wh <- read_csv("data/WHData-2018.csv")
```

# 2 Plotting Static Parallel Coordinates Plot

In this section, we will use **ggparcoord()** of **GGally** package.

## 2.1 Plotting a Simple Parallel Coordinates

```{r}
ggparcoord(data = wh,
           columns = c(7:12))
```

## 2.2 Plotting a Parallel Coordinates with Boxplot

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Parallel Coordinates Plot of World Happiness Variables")
```

## 2.3 Parallel Coordinates with Facet

The code chunk below will use **facet_wrap()** of **ggplot2** to plot 10 small multiple parallel coordinates plots.

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of World Happiness Variables by Region") +
  facet_wrap(~ Region)
```

## 2.4 Rotating x-axis text label

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of World Happiness Variables by Region") +
  facet_wrap(~ Region) + 
  theme(axis.text.x = element_text(angle = 30))
```

## 2.5 Adjusting the rotated x-axis text label

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of World Happines Variables by Region") +
  facet_wrap(~ Region) + 
  theme(axis.text.x = element_text(angle = 30, hjust=1))
```

# 3 Plotting Interactive Parallel Coordinates Plot: parallelPlot methods

**parallelPlot** is an R package designed to plot parallel coordinates plot.

## 3.1 The Basic Plot

```{r}
wh <- wh %>%
  select("Happiness score", c(7:12))
parallelPlot(wh,
             width = 320,
             height = 250)
```

## 3.2 Rotate Axis Label

```{r}
parallelPlot(wh,
             rotateTitle = TRUE)
```

## 3.3 Changing the Colour Scheme

```{r}
parallelPlot(wh,
             continuousCS = "YlOrRd",
             rotateTitle = TRUE)
```

## 3.4 Parallel Coordinates Plot with Histogram

```{r}
histoVisibility <- rep(TRUE, ncol(wh))
parallelPlot(wh,
             rotateTitle = TRUE,
             histoVisibility = histoVisibility)
```
